

%% I. GUI Preamble
% Auto-generated by Matlab's GUIDE App

%%
% * Initialize GUI
% * Initialization Code
% * Command Line Output
% * Variable Structure

%% --- Initialize GUI
% Auto-generated by Matlab's GUIDE App
function varargout = SECOND_030918(varargin)
% SECOND_030918 MATLAB code for SECOND_030918.fig
%      SECOND_030918, by itself, creates a new SECOND_030918 or raises the existing
%      singleton*.
%
%      H = SECOND_030918 returns the handle to a new SECOND_030918 or the handle to
%      the existing singleton*.
%
%      SECOND_030918('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in SECOND_030918.M with the given input arguments.
%   
%      SECOND_030918('Property','Value',...) creates a new SECOND_030918 or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before SECOND_030918_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to SECOND_030918_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help SECOND_030918

% Last Modified by GUIDE v2.5 09-Mar-2018 09:12:17

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @SECOND_030918_OpeningFcn, ...
                   'gui_OutputFcn',  @SECOND_030918_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end


%% --- Initialization Code
% Executes just before SECOND_030918 is made visible.
function SECOND_030918_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to SECOND_030918 (see VARARGIN)

% Choose default command line output for SECOND_030918
handles.output = hObject;

% initialize handles structure variables
handles.settings = struct(  'strelwidth', 5,...
                            'minholearea',double(5000),...
                            'groupwidth',5,...
                            'conv', 0.625,...
                            'briefcase', char(datetime('Now','Format','dd_MMM_y_HH_mma')),...
                            'fielddesc', {{ 'Sobel filter width';...
                                            'Minimum hole detection size limit';...
                                            'Group Width (microns)';...
                                            'Conversion factor (micron/pixel)';...
                                            'Working file name';...
                                            'Field Descriptions'}});
handles.exclusions = cell(0);
handles.exclusions_outline = cell(0);
handles.m =uint16([]);
handles.files=[];
handles.savepath=[];
handles.channels=[];
handles.bfn=[];
handles.temp = [];
handles.tbounds = [];
handles.roi=[];
handles.roi_outline=[];
handles.m_analyzed=[];
handles.I=[];
handles.lastdir = pwd;

% Update Menu Items (disable menu items until opening image)
handles = disableMenuItems(handles, [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]);

% Update handles structure
guidata(hObject, handles);


%% --- Command Line Output Code
% Outputs from this function are returned to the command line.
function varargout = SECOND_030918_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


%% --- Handles Variable structure
%
% *  .m / cell containing images / cell
% *  .files* / file paths / cell
% *  .savepath* / directory containing image files
% *  .channels* / channel names / cell
% *  .bfn* / integer pointing to bf image in m cell struct
% *  .temp / temp impage construct / uint16
% *  .tbounds / adjusted levels for images (min, max pairs)
% *  .roi* / 
% *  .roi_outline* / perimiter of outline
% *  .m_analyzed* / images with overlaid analysis
% *  .I* / analyzed intensities
% *  .exclusions* / cell structure containing exclusion ROIs
% *  .exclusions_outline / outline perimeiter
% *  .settings* / structure containing analysis settings
% *      .strelwidth / (no longer used - was used for autodetection of hole)
% *      .minholearea / (no longer used - was used for autodetection of hole)
% *      .groupwidth / bucket grouping for intensity profile, default 5um
% *      .conv / pixel um conversion factor
% *      .briefcase / place holder for save export function
% .lastdir last file open directory




%% II. MENU_FILE Callbacks
% All the callbacks for the Menu >> File dropdown

%%
%
% * Open
% * Save
%

function Menu_File_Callback(hObject, eventdata, handles)
% hObject    handle to Menu_File (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
%

%% --- File >> Open
% This menu item opens a new set of images and checks to see if a _sconfig
% file exists. If one exists it loads it with loadS(); otherwise it creates
% as new one with loadNew(). If directories are out of date, e.g., selected
% files directory does not match the path saved in _sconfig.mat, then the
% directories are updated with updateDirs()
function File_OpenSet_Callback(hObject, eventdata, handles)
% hObject    handle to File_OpenSet (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Update Menu Items (disable menu items until opening image)
handles = disableMenuItems(handles, [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]);

% initialize handles structure variables
handles.exclusions = cell(0);
handles.exclusions_outline = cell(0);
handles.m =uint16([]);
handles.files=[];
handles.savepath = [];
handles.channels=[];
handles.bfn=[];
handles.temp = [];
handles.tbounds = [];
handles.roi=[];
handles.roi_outline=[];
handles.m_analyzed=[];
handles.I=[];

% if exist('handles.lastdir', 'var') ~= 1
%     handles.lastdir = pwd;
% end

% Open file, force .tif, allow multiselection
[filename,filedir] = uigetfile({'*.tif'},'Select Image Files',handles.lastdir,'MultiSelect','on');
nfiles = numel(filename);

handles.savepath = filedir;
handles.lastdir = filedir;

% If file(s) selected, save file paths to handles.files, sort channels
% using regexpression '*_channelname.tif'
if ~isequal(filename, 0)
    
    % if a _sconfig file exists, initialize with saved data, but update dir
    if exist([handles.savepath,'_sconfig.mat'], 'file') == 2
        % Update directories
        handles =  updateDirs(handles, filedir);
        % Load config data
        handles = loadS(handles, false);
    else
        % Load new data
        handles = loadNew(handles, filename, filedir, nfiles);
    end
    
    % Set current layer to brightfield
    handles.popupmenu1.Value = handles.bfn;
    
    % Update handles structure
    guidata(hObject, handles);
    
    % Update main plot with temp data
    RefreshPlot(handles);
end

%% --- File >> Save
% Exits program without saving
function File_Close_Callback(hObject, eventdata, handles)
% hObject    handle to File_Close (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
close all;





%% III. MENU_SETUP Callbacks
% All the callbacks for the Menu >> Setup dropdown

%%
%
% * Setup Channels
% * Add Hole (Manually)
% * Setup Exclusions
% * Remove All Exclusions
% * Undo Last Exclusion
% * Save Configuration
%

function Menu_Setup_Callback(hObject, eventdata, handles)
% hObject    handle to Menu_Setup (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%% --- Setup >> Set Channels
% Provides option of changing channel names - not often used
function Setup_Channels_Callback(hObject, eventdata, handles)
% hObject    handle to Setup_Channels (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    
    % Prompt user to rename the channel names and error handling
    answer =  inputdlg(handles.files,'Update Channel Names',1,handles.channels);
    if ~isempty(answer)
        handles.channels = answer';
    end
    % Set menu text  
    set(handles.popupmenu1, 'String', handles.channels');
    % Update handles structure
    guidata(hObject, handles);

%% --- Setup >> Set Hole Manually
% Sets up GUI to prompt user to define the hole boundary ("ROI"). The
% zoomRect() function allows the user to zoom in on a specific area so that
% the ROI can be set with better accuracy. The ROI is saved as a logical
% mask where the ROI is labeled 1 and 0 everywhere else.
function Setup_Manual_Callback(hObject, eventdata, handles)
% hObject    handle to Setup_Manual (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    
    % Update Menu Items (enable menu items after successfully opening)
    handles = disableMenuItems(handles, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
        
    % Reset axis
    xlim auto;
    ylim auto;
    
    % Prompt user to zoom on ROI
    title(handles.axes1, 'Draw rectagle around ROI, double-click when finished');
    ZoomRect(handles);
    
    % Prompt user to carefully outline hole
    title(handles.axes1, 'Carefully trace inner border of hole, double-click when finished');
    myroi = roipoly;
    
    % Reset title
    title(handles.axes1, '');
    
    % Reset axis
    xlim auto;
    ylim auto;
    
    % Error checking if myroi ~= []
    if ~isempty(myroi)
        % Draw perimiter
        BWoutline = bwperim(myroi);

        % Save variables to handles structure
        handles.roi = logical(myroi);
        handles.roi_outline = BWoutline;
        
        % Update Menu Items (enable menu items after successfully adding hole)
        handles = disableMenuItems(handles, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
    end
    
    % Update handles structure
    guidata(hObject, handles);
       
    % Refresh plot
    RefreshPlot(handles, handles.popupmenu1.Value);
    
%% --- Setup >> Define Exclusions
% Sets up GUI to prompt user to define the exclusions using the same
% prompts and flow as the hole definition. Exclusions are labeled as NaN
% and 0 everywhere else. Since multiple exlclusions can be made, they are
% stored in a cell array, where each cell contains a single exclusion mask
% with the same dimensions as the image.
function Setup_Exclusions_Callback(hObject, eventdata, handles)
% hObject    handle to Setup_Exclusions (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    %handles.exclusions
    
    % Update Menu Items (disable menu items until operation complete)
    handles = disableMenuItems(handles, [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]);
    
    % Reset axis
    xlim auto;
    ylim auto;
    
    % Prompt user to zoom on ROI
    title(handles.axes1, 'Draw rectagle around ROI, double-click when finished');
    ZoomRect(handles);
    
    % Prompt user to circle the region to add
    title(handles.axes1, 'Carefully outline region exclude, double-click when finished');
    myroi = roipoly;
    
    % Output if successful roipoly
    %mydebug = 'successfully completed ROI, moving on to next code'
    %isempty (myroi)
    
    % Reset title
    title(handles.axes1, '');
    
    % Reset axis
    xlim auto;
    ylim auto;
    
    % Draw perimiter
    BWoutline = bwperim(myroi);

    % Set exclusion ROI to NaN
    myroi = double(myroi);
    myroi(myroi==1) = NaN;
    
    % Save variables to handles structure
    % Error checking - if exclusions not []
    if ~isempty (myroi)
        nn = numel(handles.exclusions);
        handles.exclusions{nn+1} = myroi;
        handles.exclusions_outline{nn+1} = BWoutline;
    end

    % Update Menu Items (enable menu items after successfully adding hole)
    handles = disableMenuItems(handles, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
    
    % Update handles structure
    guidata(hObject, handles);
    
    % Refresh plot
    RefreshPlot(handles, handles.popupmenu1.Value);
    
%% --- Setup >> Reset Exclusions
% This function removes all exclusions from the cell array.
function Setup_ResetExclusions_Callback(hObject, eventdata, handles)
% hObject    handle to Setup_ResetExclusions (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

    % Reset exclusions variable
    handles.exclusions = cell(0);
    handles.exclusions_outline = cell(0);
    
    % Update handles structure
    guidata(hObject, handles);
    
    % Refresh plot
    RefreshPlot(handles, handles.popupmenu1.Value);

%% --- Setup >> Remove Last Exclusion
% This function removes the last stored exclusion from the cell array
function Setup_RemoveLastExclusion_Callback(hObject, eventdata, handles)
% hObject    handle to Setup_RemoveLastExclusion (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    % Reset exclusions variable
    if numel(handles.exclusions)<2
        handles.exclusions = cell(0);
        handles.exclusions_outline = cell(0);
    else 
        handles.exclusions =  handles.exclusions(1:end-1);
        handles.exclusions_outline = handles.exclusions_outline(1:end-1);
    end
    
    % Update handles structure
    guidata(hObject, handles);
    
    % Refresh plot
    RefreshPlot(handles, handles.popupmenu1.Value);

%% --- Setup >> Save Configuration
% This function saves the sconfig file. Users should make sure to save
% after hole definition and contrast adjustment to make sure that progress
% is stored in case of crashes. If a new image is opened without saving,
% any changes will be lost.
function Setup_Save_Callback(hObject, eventdata, handles)
% hObject    handle to Setup_Save (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    % set timestamp and filename
    atime = datetime;
    fname = [handles.savepath,'_sconfig.mat'];
    
    sflag = true;
    % Check to see if file alrady exists
    if exist(fname, 'file') == 2
        b=questdlg('A configuration file already exists. Overwrite it?', 'Duplicate Detected', ...
            'Yes','No','No');
        if strcmp(b,'Yes')
            sflag = true;
        else
            sflag = false;
        end
    end
    
    % If okay to proceed, save variables otherwise do nothing
    if sflag
        files = handles.files;
        savepath = handles.savepath;
        channels = handles.channels;
        tbounds = handles.tbounds;
        bfn = handles.bfn;
        roi = handles.roi;
        roi_outline = handles.roi_outline;
        exclusions = handles.exclusions;
        exclusions_outline = handles.exclusions_outline;
        settings = handles.settings;
        save(fname, 'files',...
            'savepath',...
            'channels',...
            'tbounds',...
            'bfn',...
            'roi',... 
            'roi_outline',...
            'exclusions',...
            'exclusions_outline',...
            'settings',...
            'atime',...
            '-v7.3');
    end
% --------------------------------------------------------------------






%% IV. MENU_ANALYSIS Callbacks
% All the callbacks for the Menu >> Analysis dropdown

%%
%
% * Batch Run
% * Batch Run (Parallel Processing- disabled for now)
%

function Menu_Analysis_Callback(hObject, eventdata, handles)
% hObject    handle to Menu_Analysis (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%% --- Analysis >> Batch Run
% This function prompts the user to select a set of image folders to
% analyze. It searches for _sconfig.mat files recursively through the
% directories selected. For folders containing _sconfig files, they are
% analyzed with the AnalyzeImageTurbo() function; otherwise an error dialog is
% created to prompt the user that a config file was not found. Analysis
% resutls, thumbnail pictures and an intensity profile graph are created.

%%
% This function calls the following helper functions

%%
%
% * getSettings
% * updateDirs
% * loadS
% * getSettings
% * RefreshPlot
% * AnalyzeImageTurbo
% * ExportI
%
function Analysis_Batch_Callback(hObject, eventdata, handles)
% hObject    handle to Analysis_Batch (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    
    % Get folder directories
    mydir = uigetdir2('Select the folder(s) containing your .tif images');
    if isempty(mydir)
        return;
    end
    
    % Get settings from settings struct
    names = fieldnames(handles.settings);
    vals = struct2cell(handles.settings);
    
    % Call ui function
    vals = getSettings(handles.settings.fielddesc, vals, 3:5);
    
    % Save back to handles structure
    handles.settings = cell2struct(vals, names, 1);
    
    % Update handles structure
    guidata(hObject, handles);
    
    % Run button or cancel
    % 
    
        % Initialize progress bar
    hbar = waitbar(0,'Measuring Intensity','Name','Please wait...',...
            'CreateCancelBtn',...
            'setappdata(gcbf,''canceling'',1)');
          
    % Loop through directories and analyze
    tic
    for ii = 1:numel(mydir)
        
        % Open file and initialize with pre-config settings%%%%%%%%%%%%
        % if a _sconfig file exists, initialize with saved data
        if exist([mydir{ii},'\_sconfig.mat'], 'file') == 2
            % Update directories
            handles = updateDirs(handles, mydir{ii});
            % Load config data
            handles = loadS(handles, true);
        else
            % Load new data
            %handles = loadNew(handles, filename, filedir, nfiles);
        end
        % Set current layer to brightfield (check if exists)
        if( (handles.bfn>0) && (sum(size(handles.roi))>0) )
            handles.popupmenu1.Value = handles.bfn;
            % Update handles structure'
            guidata(hObject, handles);
            % Update main plot with temp data
            RefreshPlot(handles);
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            % Analyze image %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            handles.m_analyzed = cell(numel(handles.m)-1,1);
            handles.I = cell(numel(handles.m)-1,1);
            % Compile list of images to analyze intensity (all but non bf)
            mlist = 1:numel(handles.m);
            mlist(handles.bfn) = [];
            % Call AnalyzeImage function (runs all channels simultaneously)
            [handles.m_analyzed, handles.I] = AnalyzeImageTurbo(handles.m(mlist), handles.tbounds(mlist), handles.roi, handles.exclusions, handles.settings);
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            % Export data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            ExportI(handles.m_analyzed, handles.I, handles.roi, handles.exclusions,...
                handles.files(mlist), handles.savepath, handles.channels,...
                handles.settings, handles.bfn);
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            % Update handles structure
            guidata(hObject, handles);
        else 
            errordlg(['file: ',handles.savepath,' is missing bfn or roi definition']);
        end
        % Update progress bar
        waitbar(ii/numel(mydir), hbar);
    end
    toc
    
    delete(hbar);

%% --- Analysis >> Batch Run (Parallel Processing)
% This function uses parallel processing via the Matlab parfor command. It
% is currently disabled in this version to prevent user errors if their
% computers are not configured for parallel computing.
function Analysis_BatchParallel_Callback(hObject, eventdata, handles)
% hObject    handle to Analysis_BatchParallel (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

    % Get folder directories
    mydir = uigetdir2();
    if isempty(mydir)
        return;
    end
    
    % Get settings from settings struct
    names = fieldnames(handles.settings);
    vals = struct2cell(handles.settings);
    
    % Call ui function
    vals = getSettings(handles.settings.fielddesc, vals, 3:5);
    
    % Save back to handles structure
    handles.settings = cell2struct(vals, names, 1);
    
    % Update handles structure
    guidata(hObject, handles);
    
    % Run button or cancel
    % 
    
    % Loop through directories and analyze
    tic
    parfor ii = 1:numel(mydir)
        
        % Define temp handles structure to make compatible with parfor
        temphandles = struct();
        temphandles.savepath = [mydir{ii},'\'];
        temphandles.settings = cell2struct(vals, names, 1);
        
        % Open file and initialize with pre-config settings%%%%%%%%%%%%
        % if a _sconfig file exists, initialize with saved data
        if exist([mydir{ii},'\_sconfig.mat'], 'file') == 2
            % Update directories
            temphandles = updateDirs(temphandles, mydir{ii});
            % Load config data
            temphandles = loadSPar(temphandles, true);
        else
            % Load new data
            %handles = loadNew(handles, filename, filedir, nfiles);
        end
       
        
        % Analyze image %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        temphandles.m_analyzed = cell(numel(temphandles.m)-1,1);
        temphandles.I = cell(numel(temphandles.m)-1,1);
        % Compile list of images to analyze intensity (all but non bf)
        mlist = 1:numel(temphandles.m);
        mlist(temphandles.bfn) = [];
        % Call AnalyzeImage function (runs all channels simultaneously)
        [temphandles.m_analyzed, temphandles.I] = AnalyzeImage(temphandles.m(mlist), temphandles.tbounds(mlist), temphandles.roi, temphandles.exclusions, temphandles.settings);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        
        % Export data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        ExportI(temphandles.m_analyzed, temphandles.I, temphandles.roi, temphandles.exclusions,...
            temphandles.files(mlist), temphandles.savepath, temphandles.channels,...
            temphandles.settings, temphandles.bfn);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
    end
    toc


    



%% V. MENU_REVIEW Callbacks
% All the callbacks for the Menu >> Review dropdown

%%
%
% * Refine Image Export
%

function Menu_Review_Callback(hObject, eventdata, handles)
% hObject    handle to Menu_Review (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%% --- Review >> Refine Image Export
% This function re-exports the thumbnail images to make the contrast
% adjustment similar for all the images and overlay a boundary at 500 um
% from the hole. This works in tandem with other Review script to allow
% montage review images to be created.
function Review_Export_Callback(hObject, eventdata, handles)
% hObject    handle to Review_Export (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get folder directories
mydir = uigetdir2('Select the folder(s) containing your .tif images');
if isempty(mydir)
    return;
end

% Get settings from settings struct
names = fieldnames(handles.settings);
vals = struct2cell(handles.settings);

% Call ui function
vals = getSettings(handles.settings.fielddesc, vals, 3:5);

% Save back to handles structure
handles.settings = cell2struct(vals, names, 1);

% Update handles structure
guidata(hObject, handles);

% Run button or cancel
% 

    % Initialize progress bar
hbar = waitbar(0,'Measuring Intensity','Name','Please wait...',...
        'CreateCancelBtn',...
        'setappdata(gcbf,''canceling'',1)');

% Loop through directories and analyze
tic
for ii = 1:numel(mydir)
    if exist([mydir{ii},'\_analysisresults.mat'], 'file') == 2
        % Open file and initialize with pre-config settings%%%%%%%%%%%%
        % if a _sconfig file exists, initialize with saved data
        if exist([mydir{ii},'\_sconfig.mat'], 'file') == 2
            % Update directories
            handles = updateDirs(handles, mydir{ii});
            % Load config data
            handles = loadS(handles, true);
        else
            % Load new data
            %handles = loadNew(handles, filename, filedir, nfiles);
        end
        % Set current layer to brightfield (check if exists)
        if( (handles.bfn>0) && (sum(size(handles.roi))>0) )
            handles.popupmenu1.Value = handles.bfn;
            % Update handles structure'
            guidata(hObject, handles);
            % Update main plot with temp data
            RefreshPlot(handles);
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            % Import Image Analysis %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            handles.m_analyzed = cell(numel(handles.m)-1,1);
            handles.I = cell(numel(handles.m)-1,1);
            % Compile list of images to analyze intensity (all but non bf)
            mlist = 1:numel(handles.m);
            mlist(handles.bfn) = [];
            % Call AnalyzeImage function (runs all channels simultaneously)
           
            % Initialize analysis parameters
            CONV = handles.settings.conv;
            GROUPWIDTH = handles.settings.groupwidth;
            
            % Measure background at 500 microns from hole
            myResults = load([mydir{ii},'\_analysisresults.mat']);
            bkgd = myResults.I(5:end,edge(myResults.I(1,:)>(500*CONV))>0);
            
            for zz = 1:numel(mlist)
                handles.tbounds{mlist(zz)} = [bkgd(zz)/2, bkgd(zz)*4];
            end
           
            % Apply contrast parameters to output image
            handles.m_analyzed = cellfun(@applyContrast, handles.m(mlist), handles.tbounds(mlist), 'UniformOutput', false);

            % Calculate distance transform for ROI
            distmap = bwdist(handles.roi);
            mysubs = floor((distmap-1)/(GROUPWIDTH/CONV))+2;

            %m2 = marked image with background boundary 500 micron
            myedges = edge(distmap>(500/CONV)); 
            
            % Apply perimiter line to output image
            for jj = 1:numel(handles.m_analyzed)
                handles.m_analyzed{jj}(myedges) = 2^16-1;
            end
            
            % Update handles structure'
            guidata(hObject, handles);
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            % Export Images %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            ExportIOnly(handles.m_analyzed, handles.roi, handles.exclusions,...
                handles.files(mlist));
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            % Update handles structure
            guidata(hObject, handles);
        else 
            errordlg(['file: ',handles.savepath,' is missing bfn or roi definition']);
        end

    else
        errordlg(['file: ',handles.savepath,' is missing analysisresults.mat'])
    end
    
    % Update progress bar
    waitbar(ii/numel(mydir), hbar);
end
toc
delete(hbar);






%% V. UI-FORM Callbacks
% Includes callbacks for GUI buttons, popup menus etc.

%%
%
% * Selection Change in Layer Dropdown
% * Button Pressed: Adjust Contrast 
% * Button Pressed: Reset Layer
%


%% --- Selection Change in Layer Dropdown
% Executes on selection change in popupmenu1. Selects which channel to
% display.
function popupmenu1_Callback(hObject, eventdata, handles)
% hObject    handle to popupmenu1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hints: contents = cellstr(get(hObject,'String')) returns popupmenu1 contents as cell array
%        contents{get(hObject,'Value')} returns selected item from popupmenu1
    RefreshPlot(handles, hObject.Value);

function popupmenu1_CreateFcn(hObject, eventdata, handles)
% hObject    handle to popupmenu1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end
set(hObject, 'String', 'Select layer');

%% --- Button Pressed: Adjust Contrast 
% Executes on button press in pushbutton2 to adjust the visible contrast
% via the imcontrast2() function which was adapted from the Matlab standard
% imcontrast function.
function pushbutton2_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% ADJUST CONTRAST    
    % Update graph with plain image
    imshow(handles.temp{handles.popupmenu1.Value},'Parent',handles.axes1);
    
    % Get image handle
    h1 = findobj(handles.axes1,'Type','image');
    
    % Disable all the menus until yiou close the contrast tool
    handles = disableMenuItems(handles, [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    
    % Open contrast tool
    uiwait(imcontrast2(h1));
    
    % Re-enable the menus
    handles = disableMenuItems(handles, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
    
    % Save Clim to axes1
    handles.tbounds{handles.popupmenu1.Value} = handles.axes1.CLim;   
    
    % Update handles structure
    guidata(hObject, handles);
    
    % Refresh plot to add hole and exclusion lines
    RefreshPlot(handles, handles.popupmenu1.Value);    
    
%% --- Button Pressed: Reset Layer
% Executes on button press in pushbutton3. Rests the contrast adjustment.
function pushbutton3_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton3 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% RESET LAYER    
    % Reset temp image
    handles.temp{handles.popupmenu1.Value} = handles.m{handles.popupmenu1.Value};
    
    % Set tbounds
    handles.tbounds = cellfun(@(x) double([min(min(x)), max(max(x))]), handles.temp, 'UniformOutput', false);
    
    % Update handles structure
    guidata(hObject, handles);
    
    % Refresh plot
    RefreshPlot(handles, handles.popupmenu1.Value);

    
    




%% VII. HELPER Functions
% Includes all the helper functions

%%
%
% * RefreshPlot
% * AnalyzeImageTurbo
% * ZoomRect
% * disableMenuItems
% * ExportI
% * applyContrast
% * getSettings
% * loadS
% * loadNew
% * posthoc
% * minDist
% * updateDirs
% * loadSPar
% * ExportIOnly
%

%% --- RefreshPlot
% This function updates the main figure axes on the GUI
function RefreshPlot(handles, channel)
    % Handle variable args
    if nargin < 2
        channel = handles.bfn;
    end
    
    % Clear current axis and intitialize temp
    axes(handles.axes1);
    cla;
    temp = handles.temp{channel};
    
    % Apply contrast
    temp = imadjust(temp, (handles.tbounds{channel}/65535)', [0;1]); 
    
    % Split into RGB channels
    r = temp;
    g = temp;
    b = temp;

    % Add roi outline (yellow)
    if ~isempty(handles.roi_outline)
        r(handles.roi_outline) = 65535;
        g(handles.roi_outline) = 65535;
        b(handles.roi_outline) = 0;
    end

    % If exclusions exist, add exclusions outline to image (red)
    if ~isempty(handles.exclusions)
        for ii = 1:numel(handles.exclusions)
            r(handles.exclusions_outline{ii}) = 65535;
            g(handles.exclusions_outline{ii}) = 0;
            b(handles.exclusions_outline{ii}) = 0;
        end
    end
    
    % Construct RGB
    temp = repmat(temp,1,1,3);
    temp(:,:,1) = r;
    temp(:,:,2) = g;
    temp(:,:,3) = b;

    % Refresh image in axes1
    imshow(temp,'Parent',handles.axes1);
    
    % Update contrast of axes1 to CLIM
    %handles.axes1.CLim = handles.tbounds{channel};
    
    % Default to zoom function
    zoom on;

%% --- AnalyzeImageTurbo
% This function analyzes the intensity of the image, given the hole ("roi")
% and the exclusions. It outputs both a JPG and a PNG summary of the
% intensity analysis and ultimately creates the MAT file
% _analysisresults.mat

%%
% _analysisresults.mat file structure

%%
%
% * row1 = min distance vector
% * row 2 = max distance vector
% * row 3 = mean distance vector
% * row 4 = pixel weighting vector
% * row 5+= intensity channels data
%

%%
% This function calls the following helper functions

%%
%
% * applyContrast
%
function [m2, I] = AnalyzeImageTurbo(m1, tbounds, roi, exclusions, settings)
% --- This function analyzes an intensity given an image and a mask,
% returns an annotated image and intensity curves m1 is the intensity image
% to be analyzed tempmask is the starting hole mask exlusions is a cell
% struct containing exclusion masks used to creat excludemask Return values
% are m2 = analyzed image, I = intensity array vector

    % Initialize analysis parameters
    CONV = settings.conv;
    GROUPWIDTH = settings.groupwidth;
     
    % Apply contrast parameters to output image
    m2 = cellfun(@applyContrast, m1, tbounds, 'UniformOutput', false);
    
    % Initialize exludemask
    excludemask = ones(size(m1{1}),'double');
    
    % Exclude the hole
    excludemask(roi) = NaN;
    
    % If there are any exclusions, apply them now
    if numel(exclusions) > 0
        for ii = 1:numel(exclusions)
            excludemask = excludemask.*(1-exclusions{ii});
        end
    end
    
    % Apply exclude mask to all m
    m1 = cellfun(@(x) double(x).*excludemask, m1, 'UniformOutput', false);
    
    % Calculate distance transform for ROI
    distmap = bwdist(roi);
    mysubs = floor((distmap-1)/(GROUPWIDTH/CONV))+2;

    % For each image in m cell, calculate the mean distance for the ring
    myI = cell(1,numel(m1));
    for ii = 1:numel(m1)
        myI{ii} = accumarray(mysubs(:), double(m1{ii}(:)), [], @(x) mean(x, 'omitnan'));
    end
    
    % Calc the mean intensity by ring and the total number of pixels per
    % ring (same for all images)
    myArea = accumarray(mysubs(:), double(excludemask(:)), [], @(x) sum(~isnan(x)));
    myDist = accumarray(mysubs(:), distmap(:).*excludemask(:), [], @(x) mean(x, 'omitnan'));
    myMin = accumarray(mysubs(:), distmap(:).*excludemask(:), [], @(x) min(x, [], 'omitnan'));
    myMax = accumarray(mysubs(:), distmap(:).*excludemask(:), [], @(x) max(x, [], 'omitnan'));
    
    % Construct the output variable I for the _analysisresults.mat file
    I = [myMin';myMax';myDist';myArea';cell2mat(myI)'];
    I = I(:,2:end);
    
    % Apply perimiter line to output image
    % m2 = marked image with boundary
    myedges = edge(mysubs); 
        for jj = 1:numel(m2)
            m2{jj}(myedges) = 2^16-1;
        end

        
%% --- ZoomRect
% This function performs the image zoom function during hole and exclusion
% definitions
function ZoomRect(handles)
    % Zoom in on ROI
    h = imrect(handles.axes1);
    position = wait(h);
    % Debug completed rect
    % myoutdebug = 'sucessfully completed imrect'
    delete(h);
    if ~isempty(position)
        xlim([position(1), position(1)+position(3)]);
        ylim([position(2),position(2)+position(4)]);
    end

%% --- disableMenuItems
% This function disables and enables GUI menu and button items during
% certain times during the program. A logical array is passed to the
% function to define what state the program should be in. 
% For more information see the following file: 

%%
% <file:///B:\PostDoc\Andrew%20Shoffstall\Working%20Documents\1%20-%20SECOND%20Project\IntensityAnalysis\SECOND\MenuVisibility(Program%20Flow)_Updated020317.xlsx>

%%
% 
% <<ProgramFlowScreenCap.JPG>>
% 

function handles = disableMenuItems(handles, items)
% This function is passed menu items to close based on a vector of logical
% flags 'items'
    MenuItems = {'File_OpenSet',...
                    'File_Close',...
                    'Setup_autoContrast',...
                    'Setup_Channels',...
                    'Setup_Manual',...
                    'Setup_Exclusions',...
                    'Setup_ResetExclusions',...
                    'Setup_RemoveLastExclusion',...
                    'Setup_Save',...
                    'Analysis_Batch',...
                    'Analysis_BatchParallel',...
                    'pushbutton2',...
                    'pushbutton3',...
                    'popupmenu1'                    
                 };
    
    % Turn On/Off menu items
    for ii=1:numel(items)
        if items(ii) == 1
            handles.(MenuItems{ii}).Enable = 'on';
        else
            handles.(MenuItems{ii}).Enable = 'off';
        end
    end

%% --- ExportI
% This function generates the down-sampled thumbnail of the masked images
% and exports them as JPGs. It also calls posthoc() to generate the
% intensity profile plots
function ExportI(m, I, h, x, fnames, s, c, settings, bfn)
    
    % m = original image
    % I = intensity plot
    % h = hole mask (logical)
    % x = exclusion masks (cell)
    % fnames = filenames
    % savepath
    % channels

    for jj = 1:numel(m)
        % Convert m_analyzed to uint8 (downsample to reduce storage)
        m{jj} = uint8((m{jj}+1)./256+1);

        % Create RGB image
        m3 = zeros([size(m{jj}),3],'uint8');
        m3(:,:,1) = m{jj};
        m3(:,:,2) = m{jj};
        m3(:,:,3) = m{jj};
        
        % Overlay hole in yellow
        temp = m{jj};
        temp(h) = 255;
        m3(:,:,1) = temp;
        m3(:,:,2) = temp;
        temp(h) = 0;
        m3(:,:,3) = temp;

        % Overlay exclusions in RED. If there are any exclusions, apply them now
        if numel(x) > 0
            excludemask = ones(size(m{1}),'double');
            % Apply exclusions
            for ii = 1:numel(x)
                %m1 = double(m1).*(1-exclusions{ii});
                excludemask = excludemask.*(1-x{ii});
            end
            excludemask = logical(1-uint8(excludemask));
            temp = m3(:,:,1);
            temp(excludemask) = 255;
            m3(:,:,1) = temp;
            temp = m3(:,:,2);
            temp(excludemask) = 0;
            m3(:,:,2) = temp;
            temp = m3(:,:,3);
            temp(excludemask) = 0;
            m3(:,:,3) = temp;
        end
        
        % Overlay scalebar in black
        mscale = 0.625; % microns per pixel
        mbar = 200;  % microns
        mpixs = round(mbar/mscale);
        m3((floor(end*.95)-20):floor(end*.95), floor(end*.05):(floor(end*.05)+mpixs), 1) = 0;
        m3((floor(end*.95)-20):floor(end*.95), floor(end*.05):(floor(end*.05)+mpixs), 2) = 0;
        m3((floor(end*.95)-20):floor(end*.95), floor(end*.05):(floor(end*.05)+mpixs), 3) = 0;
         
        % Save image file
        imwrite(m3, [fnames{jj},'_out.jpg'], 'jpg');

        %figure(); imshow(m3);
    end
    

    % Set filename
    fname = [s,'_analysisresults.mat'];

    % Save data
    files = fnames;
    savepath = s;
    channels = c;
    save(fname, 'files',...
                'savepath',...
                'channels',...
                'settings',...
                'I');
    
    % Plot output
    
    Posthoc(I, channels, bfn, s, settings.conv);

%% --- applyContrast
% This function adjusts contrast of the image given upper and lower
% intensity bounds
function m2 = applyContrast(m1, tbounds)
    m2 = uint16(65535*(double(m1)-tbounds(1))/(tbounds(2)-tbounds(1)));


%% --- getSettings
% This function provides the user with a prompt for analysis settings
function vals = getSettings(fielddesc, vals, idx)
    
    % Convert all vals to strings, save to vals2
    vals2(idx) = cellfun(@num2str,vals(idx),'UniformOutput',0);
    
    % Collect input using dlg form
    answer =  inputdlg(fielddesc(idx),...
                'Configure Analysis Settings',...
                1,...
                vals2(idx));
    if ~isempty(answer)
        vals2(idx) = answer;
    end

    % Convert input strings back to original datatypes
    for ii = idx(1):idx(end)
        if ischar(vals{ii})
            vals{ii} = vals2{ii};
        else 
            vals{ii} = str2double(vals2{ii});
        end
    end
    
%% --- loadS
% This function checks for existing _sconfig files and loads them
function handles = loadS(handles, bflag)
    % Load data into Sconfig
    Sconfig = load([handles.savepath,'_sconfig.mat']);

    % Update handles
    handles.files = Sconfig.files;
    handles.channels = Sconfig.channels;
    handles.tbounds = Sconfig.tbounds;
    handles.bfn = Sconfig.bfn;
    handles.roi = Sconfig.roi;
    handles.roi_outline = Sconfig.roi_outline;
    handles.exclusions = Sconfig.exclusions;
    handles.exclusions_outline = Sconfig.exclusions_outline;
    if bflag
        % do nothing - let batch settings override
    else
        handles.settings = Sconfig.settings;
    end

    % Update local variables
    nfiles = numel(handles.files);

    % Delete Sconfig
    clear Sconfig
    
    % Initialize m structure to hold all channels of file
    handles.m = cell(nfiles, 1);
    
    for ii = 1:nfiles
        % Set menu text  
        set(handles.popupmenu1, 'String', handles.channels');

        % Set handles.m to hold image data, cell structure, check if size
        % is single intensity channel, error and skip if not
        tempm = imread(handles.files{ii});
        if size(tempm,3)==1 && isa(tempm,'uint16')
            handles.m{ii} = tempm;
        else
            msgbox(['Error: image ',handles.channels{ii},...
                ' is not a B&W 16-bit. Open aborted']);
            % Update Menu Items (disable menu items until opening image)
            %handles = disableMenuItems(handles, [1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0]);
            %return;
       end
    end 
    
    
    % Update Menu Items (enable menu items after successfully adding hole)
    handles = disableMenuItems(handles, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
    
    % Set temp layers
    handles.temp = handles.m;
    
%% --- loadNew
% This function creates a new _sconfig file the first time a set of images
% is opened
function handles = loadNew(handles, filename, filedir, nfiles)
    % Initialize handles.files
    handles.files = cell(nfiles,1);

    % Initialize m structure to hold all channels of file
    handles.m = cell(nfiles, 1);

    % Setup rflag 
    rflag = false([nfiles,1]);
    
    % Loop through file paths
    for ii = 1:numel(filename)
        % If no config file exists, determine channel names
        % Set handles.files to file paths, datatype = cell
        handles.files{ii} = [filedir,filename{ii}];
        % Set handles.channels to last part of filename after '_'
        cnamed = strfind(handles.files{ii},'_');
        if ~isempty(cnamed)
            handles.channels{ii} = handles.files{ii}(max(cnamed)+1:end-4);
        else
            handles.channels{ii} = filename{ii};
        end

        % Set menu text
        set(handles.popupmenu1, 'String', handles.channels');

        % Set handles.m to hold image data, cell structure, check if size
        % is single intensity channel, error and skip if not
        tempm = imread(handles.files{ii});
        if size(tempm,3)==1 && isa(tempm,'uint16')
            handles.m{ii} = tempm;
            rflag(ii) = false;
        else
            msgbox(['Error: image ',handles.channels{ii},...
                ' is not a B&W 16-bit. Open aborted']);
            handles.channels{ii}='8-bit image did not load';
            rflag(ii) = true;
        end
    end
    
    % Clean up unused channels
    for ii=nfiles:-1:1
        if rflag(ii)
            handles.channels(ii) = [];
            handles.m(ii) = [];
            handles.files(ii) = [];
            % Set menu text  
            set(handles.popupmenu1, 'String', handles.channels');
        end
    end     

    % Prompt user to select the brightfield channel and error handling
    v = 0;
    b = 0;
    while v == 0 && b == 0
        [bfchannel,v] = listdlg('PromptString','Select the brightfield channel:',...
            'SelectionMode','single',...
            'ListString',handles.channels);
        % If no bf channel selected prompt for exit
        if v == 0
            b = questdlg(qstring,'Abort close or try again...',...
                'Abort Open','Select BF Channel');
            if b == 1
                error('Error: must select a bf image to continue.');
            end
        end
    end

    % Set bfn as index of m structure containing bf image
    handles.bfn = bfchannel;

    % Update Menu Items (enable menu items after successfully opening)
    handles = disableMenuItems(handles, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);

    % Set temp layers
    handles.temp = handles.m;

    % Set tbounds
    handles.tbounds = cellfun(@(x) double([min(min(x)), max(max(x))]), handles.temp, 'UniformOutput', false);
    
%% --- Posthoc
% This function generates intensity plots and saves them as a PNG figure in
% the image folder directory
function h = Posthoc(I, channels, bfn, s, conv)
% will output analyzed data figures and stats

    % Initialize variables
    h = figure(); 
    title('Intensity Plots');
    mlist = 1:size(channels,2);
    mlist(bfn) = [];
    %conv = 0.666; % micron/pixel

    % Create subplot - 1: lineplot
    subplot(2,1,1);
        plot(I(3,:)*conv, I(5:end,:));
        legend(channels{mlist});
        xlabel('Distance from hole (microns)');
        ylabel('Raw intensity');
    
    % Calculate bar graph params
    groupwidth = 50; % microns
    mysubs = floor(I(3,:)'*conv/groupwidth)+1;
    
    % Calculate weighted responses
    w = zeros([size(I,1)-4,size(I,2)],'double');
    y = cell(size(I,1)-4,1);
    
    for ii = 1:numel(mlist)
        w(ii,:) = I(ii+4,:).*I(4,:);
        y{ii}=accumarray(mysubs(~isnan(mysubs)), w(ii,~isnan(mysubs)), [], @sum);
        y{ii}=y{ii}./accumarray(mysubs(~isnan(mysubs)), I(4,~isnan(mysubs)), [], @sum);
    end
    
    bardatay = cell2mat(y');
    bardatax = groupwidth * (1:size(bardatay,1))';
   
    
    % Create subplot - 2: bargraph
    subplot(2,1,2);
        bar(bardatax,bardatay);
        legend(channels{mlist});
        xlabel('Distance from hole (microns)');
        ylabel('Raw intensity');
    
    % Print to png
    fname = [s,'_intensityplot.png'];
    print(h, fname, '-dpng');
    close(h);
    
%% --- minDist
% This function calculates the minimum distance of a ring to the nearest
% point on the ROI edge. (Not used in current implementation as bwdist() to
% build a distance map from the ROI was a more efficient method
function [MeanMinDistance] = minDist(ringmask, perim)
[ringcoory, ringcoorx] = find(ringmask);
[perimy, perimx] = find(perim);

% Define object boundaries
minDistance = zeros(size(ringcoorx),'double');
% For every point in perim, find the distance to every point in ringmask.
for k = 1 : size(ringcoorx)
	% Pick the next point on boundary 2.
	boundary2x = ringcoorx(k);
	boundary2y = ringcoory(k);
	% For this point, compute distances from it to all points in boundary 1.
	allDistances = sqrt((perimx - boundary2x).^2 + (perimy - boundary2y).^2);
	% Find closest point, min distance.
	minDistance(k) = min(allDistances);
end
% Find the overall mean of the min distances
MeanMinDistance = mean(minDistance);

%% --- updateDirs
% This function determines if the current directory listed in the SCONFIG
% file is out of date, and updates is as needed.
function handles = updateDirs(handles, mydir)
    % Load data into Sconfig
    Sconfig = load([mydir,'\_sconfig.mat']);
    % Update handles
    handles.files = Sconfig.files;
    handles.channels = Sconfig.channels;
    handles.tbounds = Sconfig.tbounds;
    handles.bfn = Sconfig.bfn;
    handles.roi = Sconfig.roi;
    handles.roi_outline = Sconfig.roi_outline;
    handles.exclusions = Sconfig.exclusions;
    handles.exclusions_outline = Sconfig.exclusions_outline;
    
    % Create temporary writable matfile
    mymatfile = matfile([mydir,'\_sconfig.mat'],'Writable',true);
    % Update savepath
    mymatfile.savepath = [mydir,'\'];
    handles.savepath = [mydir,'\'];
    % Update directories of files
    tempfiles = Sconfig.files;
    for zz = 1:length(Sconfig.files)
        dashloc = strfind(Sconfig.files{zz},'\');
        tempfiles{zz} = [mymatfile.savepath,Sconfig.files{zz}(dashloc(end)+1:end)];
    end
    mymatfile.files = tempfiles;
    clear mymatfile;
    
%% --- loadSPar
% This function is used for loading multiple files  - for use in parallel
% processing mode, e.g. with use of cluster computing
function handles = loadSPar(handles, bflag)
    % Load data into Sconfig
    Sconfig = load([handles.savepath,'_sconfig.mat']);

    % Update handles
    handles.files = Sconfig.files;
    handles.channels = Sconfig.channels;
    handles.tbounds = Sconfig.tbounds;
    handles.bfn = Sconfig.bfn;
    handles.roi = Sconfig.roi;
    handles.roi_outline = Sconfig.roi_outline;
    handles.exclusions = Sconfig.exclusions;
    handles.exclusions_outline = Sconfig.exclusions_outline;
    if bflag
        % do nothing - let batch settings override
    else
        handles.settings = Sconfig.settings;
    end

    % Update local variables
    nfiles = numel(handles.files);

    % Delete Sconfig
    clear Sconfig
    
    % Initialize m structure to hold all channels of file
    handles.m = cell(nfiles, 1);
    
    for ii = 1:nfiles
        % Set menu text  
        %set(handles.popupmenu1, 'String', handles.channels');

        % Set handles.m to hold image data, cell structure, check if size
        % is single intensity channel, error and skip if not
        tempm = imread(handles.files{ii});
        if size(tempm,3)==1 && isa(tempm,'uint16')
            handles.m{ii} = tempm;
        else
            msgbox(['Error: image ',handles.channels{ii},...
                ' is not a B&W 16-bit. Open aborted']);
            % Update Menu Items (disable menu items until opening image)
            %handles = disableMenuItems(handles, [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]);
            %return;
       end
    end 
    
    
    % Update Menu Items (enable menu items after successfully adding hole)
    %handles = disableMenuItems(handles, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1]);
    
    % Set temp layers
    handles.temp = handles.m;
    
%% --- ExportIOnly
% This function is used in conjunction with the Review menu to update the
% JPG thumbnails to all have similar contrast based on the background
% intensity @ 500 microns from the hole. It also adds an outline of 500
% micron boundary from the hole.
function ExportIOnly(m, h, x, fnames)
    
    % m = original image
    % I = intensity plot
    % h = hole mask (logical)
    % x = exclusion masks (cell)
    % fnames = filenames
    % savepath
    % channels

    for jj = 1:numel(m)
        % Convert m_analyzed to uint8 (downsample to reduce storage)
        m{jj} = uint8((m{jj}+1)./256+1);

        % Create RGB image
        m3 = zeros([size(m{jj}),3],'uint8');
        m3(:,:,1) = m{jj};
        m3(:,:,2) = m{jj};
        m3(:,:,3) = m{jj};
        
        % Overlay hole in yellow
        temp = m{jj};
        temp(h) = 255;
        m3(:,:,1) = temp;
        m3(:,:,2) = temp;
        temp(h) = 0;
        m3(:,:,3) = temp;

        % Overlay exclusions in RED. If there are any exclusions, apply them now
        if numel(x) > 0
            excludemask = ones(size(m{1}),'double');
            % Apply exclusions
            for ii = 1:numel(x)
                %m1 = double(m1).*(1-exclusions{ii});
                excludemask = excludemask.*(1-x{ii});
            end
            excludemask = logical(1-uint8(excludemask));
            temp = m3(:,:,1);
            temp(excludemask) = 255;
            m3(:,:,1) = temp;
            temp = m3(:,:,2);
            temp(excludemask) = 0;
            m3(:,:,2) = temp;
            temp = m3(:,:,3);
            temp(excludemask) = 0;
            m3(:,:,3) = temp;
        end
        
        % Overlay scalebar in black
        mscale = 0.625; % microns per pixel
        mbar = 200;  % microns
        mpixs = round(mbar/mscale);
        m3((floor(end*.95)-20):floor(end*.95), floor(end*.05):(floor(end*.05)+mpixs), 1) = 0;
        m3((floor(end*.95)-20):floor(end*.95), floor(end*.05):(floor(end*.05)+mpixs), 2) = 0;
        m3((floor(end*.95)-20):floor(end*.95), floor(end*.05):(floor(end*.05)+mpixs), 3) = 0;
         
        % Save image file
        imwrite(m3, [fnames{jj},'_out.jpg'], 'jpg');

        %figure(); imshow(m3);
    end
    


% --------------------------------------------------------------------
function CompileResultsSet_Callback(hObject, eventdata, handles)
% hObject    handle to CompileResultsSet (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
%% Analysis settings

%     % Set channel of interest
%     mychannel = 'mPlum';
%     
%     % Set conversion factor (microns per pixel)
%     conv = 0.625;
% 
%     % Set background distance in microns
%     bk_lower = 600;
%     bk_upper = 650;
%     
%     % Set normalization method
%         % Norm method 0 = (I/bk -1);  set to zero anything below bk (CD68, IgG)
%         % Norm method 1 = (I/bk); set to one anything below bk (GFAP, IBA1)
%     norm_method = 0;
%     
%     % Bar group width (in microns)
%     groupwidth = 50;
    
    fieldsdesc = {'Channel Name'; 'Conversion Factor um/pixel'; 'Bkgd Lower Bound (um)';...
                  'Bkdg Upper Bound (um)'; 'Normalization to 0 or 1'; 'Group Width (um)'};
    
    % Set default values
    vals = {'mPlum', 0.625, 600, 650, 0, 50};
    
    % Get user to confirm values
    vals = getSettings(fieldsdesc, vals, 1:6);  
    
    % Error checking
    % [channel, conv, bkg1, bkgd2, norm, group]
    flg = zeros(6,1);
    if numel(vals{1}) < 1
        flg(1) = 1;
    end
    if vals{2} <= 0
        flg(2) = 1;
    end
    if vals{4} <= vals{3} 
        flg(3) = 1;
    end
    if vals{3} <= 0 || vals{4} <= 0
        flg(4) = 1;
    end
    if ~(vals{5} == 1 || vals{5} == 0)
        flg(5) = 1;
    end
    if vals{6} <= 0
        flg(6) = 1;
    end
    
    if sum(flg) == 0
        CompileAnalyzedResultsFCN(vals{1},vals{2},vals{3},vals{4},vals{5},vals{6});
    else
        errordlg(['Inputs ' horzcat(num2str(find(flg)')), ' contained errors - Please correct and try again'])
    end


% --------------------------------------------------------------------
function Setup_autoContrast_Callback(hObject, eventdata, handles)
% hObject    handle to Setup_autoContrast (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    
    % Reset temp image
    handles.temp{handles.popupmenu1.Value} = handles.m{handles.popupmenu1.Value};
    
    % Set tbounds
    handles.tbounds{handles.popupmenu1.Value} = stretchlim(handles.m{handles.popupmenu1.Value}) * 65535;
    
    % Update handles structure
    guidata(hObject, handles);
    
    % Refresh plot
    RefreshPlot(handles, handles.popupmenu1.Value);
